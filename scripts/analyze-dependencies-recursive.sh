#!/usr/bin/env bash
# Recursive dependency analyzer - crawls thunks to build complete dependency tree
# This finds ALL transitive dependencies that will be needed at build time

set -euo pipefail

OVERLAY_FILE="cardano-project/cardano-overlays/cardano-packages/default.nix"
OUTPUT_FILE="recursive-dependency-analysis.md"
TEMP_DIR=$(mktemp -d)

trap "rm -rf $TEMP_DIR" EXIT

echo "üîç Recursive Dependency Analysis"
echo "================================"
echo ""

# Step 1: Get our direct dependencies
echo "Step 1: Analyzing workspace .cabal files..."
WORKSPACE_CABAL_FILES=$(find . -name "*.cabal" -type f ! -path "*/result/*" ! -path "*/.stack-work/*" ! -path "*/dist-newstyle/*" 2>/dev/null || true)
WORKSPACE_CABAL_COUNT=$(echo "$WORKSPACE_CABAL_FILES" | grep -v '^$' | wc -l | tr -d ' ')
echo "  Found $WORKSPACE_CABAL_COUNT workspace .cabal files"

# Extract dependencies from our code
extract_deps_from_cabal() {
  local cabal_file="$1"
  awk '
    BEGIN { in_deps = 0 }
    /^[[:space:]]*build-depends:/ {
      in_deps = 1
      line = $0
      sub(/^[[:space:]]*build-depends:[[:space:]]*/, "", line)
      if (line != "" && line !~ /^[[:space:]]*$/) print line
      next
    }
    in_deps == 1 {
      if (/^[[:space:]]*$/) { in_deps = 0; next }
      if (/^[a-zA-Z].*:/ && !/^[[:space:]]/) { in_deps = 0; next }
      if (/^[[:space:]]+/) { print $0 }
    }
  ' "$cabal_file" | \
  tr ',' '\n' | \
  sed 's/--.*$//' | \
  sed 's/^[[:space:]]*//' | \
  sed 's/[[:space:]]*$//' | \
  sed 's/[[:space:]]*{.*$//' | \
  sed 's/[[:space:]]*[><=^].*$//' | \
  grep -v '^$' | \
  grep -E '^[a-z][a-z0-9-]*$' || true
}

DIRECT_DEPS=""
for cabal in $WORKSPACE_CABAL_FILES; do
  DIRECT_DEPS="$DIRECT_DEPS
$(extract_deps_from_cabal "$cabal")"
done

DIRECT_DEPS=$(echo "$DIRECT_DEPS" | grep -v '^$' | sort -u)
DIRECT_DEP_COUNT=$(echo "$DIRECT_DEPS" | grep -v '^$' | wc -l | tr -d ' ')
echo "  Found $DIRECT_DEP_COUNT unique direct dependencies"
echo ""

# Step 2: Get packages defined in overlay
echo "Step 2: Loading overlay definitions..."
DEFINED_PACKAGES=$(grep -E '^  [a-z][a-z0-9-]+ =' "$OVERLAY_FILE" | \
  sed 's/^  //' | \
  sed 's/ =.*//' | \
  sort -u)
DEFINED_COUNT=$(echo "$DEFINED_PACKAGES" | wc -l | tr -d ' ')
echo "  Found $DEFINED_COUNT packages in overlay"

NULL_PACKAGES=$(grep -E '^  [a-z][a-z0-9-]+ = null' "$OVERLAY_FILE" | \
  sed 's/^  //' | \
  sed 's/ =.*//' | \
  sort -u)
NULL_COUNT=$(echo "$NULL_PACKAGES" | wc -l | tr -d ' ')
echo "  $NULL_COUNT packages set to null"
echo ""

# Step 3: Categorize dependencies
echo "Step 3: Categorizing dependencies..."

# Standard libraries provided by GHC/nixpkgs
STANDARD_LIBS="base array bytestring containers deepseq directory filepath ghc-prim integer-gmp mtl process stm template-haskell text time transformers unix Win32 binary parsec pretty"

# Our own packages (not external dependencies)
OWN_PACKAGES="backend frontend common hydra-pay hydra-pay-core"

categorize() {
  local dep="$1"
  
  # Check if it's our own package
  for own in $OWN_PACKAGES; do
    if [ "$dep" = "$own" ]; then
      echo "OWN"
      return
    fi
  done
  
  # Check if standard library
  for std in $STANDARD_LIBS; do
    if [ "$dep" = "$std" ]; then
      echo "STDLIB"
      return
    fi
  done
  
  # Check if defined in overlay
  if echo "$DEFINED_PACKAGES" | grep -q "^$dep$"; then
    # Check if null
    if echo "$NULL_PACKAGES" | grep -q "^$dep$"; then
      echo "NULL"
    else
      echo "DEFINED"
    fi
    return
  fi
  
  echo "MISSING"
}

MISSING_DEPS=""
DEFINED_DEPS=""
NULL_DEPS=""
STDLIB_DEPS=""
OWN_DEPS=""

while IFS= read -r dep; do
  [ -z "$dep" ] && continue
  cat=$(categorize "$dep")
  case "$cat" in
    MISSING) MISSING_DEPS="$MISSING_DEPS $dep" ;;
    DEFINED) DEFINED_DEPS="$DEFINED_DEPS $dep" ;;
    NULL) NULL_DEPS="$NULL_DEPS $dep" ;;
    STDLIB) STDLIB_DEPS="$STDLIB_DEPS $dep" ;;
    OWN) OWN_DEPS="$OWN_DEPS $dep" ;;
  esac
done <<< "$DIRECT_DEPS"

MISSING_COUNT=$(echo "$MISSING_DEPS" | wc -w | tr -d ' ')
DEFINED_DEP_COUNT=$(echo "$DEFINED_DEPS" | wc -w | tr -d ' ')
NULL_DEP_COUNT=$(echo "$NULL_DEPS" | wc -w | tr -d ' ')
STDLIB_COUNT=$(echo "$STDLIB_DEPS" | wc -w | tr -d ' ')
OWN_COUNT=$(echo "$OWN_DEPS" | wc -w | tr -d ' ')

echo "  ‚úÖ $DEFINED_DEP_COUNT defined in overlay"
echo "  ‚ö†Ô∏è  $NULL_DEP_COUNT set to null"
echo "  üì¶ $STDLIB_COUNT standard libraries"
echo "  üè† $OWN_COUNT our own packages"
echo "  ‚ùå $MISSING_COUNT missing from overlay"
echo ""

# Generate report
cat > "$OUTPUT_FILE" << 'EOF'
# Recursive Dependency Analysis

Generated by analyzing all .cabal files in workspace and checking against Nix overlay.

## Summary

- **Workspace .cabal files**: WORKSPACE_COUNT
- **Direct dependencies**: DIRECT_COUNT
  - ‚úÖ Defined in overlay: DEFINED_COUNT
  - ‚ö†Ô∏è Set to null: NULL_COUNT
  - üì¶ Standard libraries: STDLIB_COUNT
  - üè† Our own packages: OWN_COUNT
  - ‚ùå Missing from overlay: MISSING_COUNT

## Missing Dependencies

These dependencies are used by our code but not defined in the overlay.
They will cause build failures unless added or their paths don't exist (should be set to null).

EOF

if [ "$MISSING_COUNT" -gt 0 ]; then
  echo "" >> "$OUTPUT_FILE"
  echo "| Status | Package | Notes |" >> "$OUTPUT_FILE"
  echo "|--------|---------|-------|" >> "$OUTPUT_FILE"
  
  for dep in $MISSING_DEPS; do
    echo "| ‚ùå | \`$dep\` | Check Hackage/thunks |" >> "$OUTPUT_FILE"
  done
fi

echo "" >> "$OUTPUT_FILE"
echo "## Defined Dependencies" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "These are correctly defined in the overlay:" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

if [ "$DEFINED_DEP_COUNT" -gt 0 ]; then
  for dep in $DEFINED_DEPS; do
    echo "- ‚úÖ \`$dep\`" >> "$OUTPUT_FILE"
  done
fi

echo "" >> "$OUTPUT_FILE"
echo "## Null Dependencies" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "These are set to null (path doesn't exist in thunk):" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

if [ "$NULL_DEP_COUNT" -gt 0 ]; then
  for dep in $NULL_DEPS; do
    echo "- ‚ö†Ô∏è \`$dep\`" >> "$OUTPUT_FILE"
  done
fi

# Update summary
sed -i.bak "s/WORKSPACE_COUNT/$WORKSPACE_CABAL_COUNT/" "$OUTPUT_FILE"
sed -i.bak "s/DIRECT_COUNT/$DIRECT_DEP_COUNT/" "$OUTPUT_FILE"
sed -i.bak "s/DEFINED_COUNT/$DEFINED_DEP_COUNT/" "$OUTPUT_FILE"
sed -i.bak "s/NULL_COUNT/$NULL_DEP_COUNT/" "$OUTPUT_FILE"
sed -i.bak "s/STDLIB_COUNT/$STDLIB_COUNT/" "$OUTPUT_FILE"
sed -i.bak "s/OWN_COUNT/$OWN_COUNT/" "$OUTPUT_FILE"
sed -i.bak "s/MISSING_COUNT/$MISSING_COUNT/" "$OUTPUT_FILE"
rm "${OUTPUT_FILE}.bak"

echo "‚úÖ Analysis complete!"
echo ""
echo "üìÑ Report: $OUTPUT_FILE"
echo ""

if [ "$MISSING_COUNT" -gt 0 ]; then
  echo "‚ö†Ô∏è  $MISSING_COUNT dependencies need attention:"
  echo ""
  for dep in $MISSING_DEPS; do
    echo "  - $dep"
  done
  echo ""
  echo "üí° Next steps:"
  echo "   1. Check if they come from thunks (dep/*/)"
  echo "   2. Check Hackage: https://hackage.haskell.org/package/{name}"
  echo "   3. Add to overlay or set to null if path doesn't exist"
else
  echo "‚úÖ All direct dependencies are accounted for!"
fi
